<!DOCTYPE html>
<!--[if IE 8]> <html lang="fr" class="ie8"> <![endif]-->  
<!--[if IE 9]> <html lang="fr" class="ie9"> <![endif]-->  
<!--[if !IE]><!--> <html lang="fr"> <!--<![endif]-->  
<head>
    <title>Documentation</title>
    <!-- Meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">    
    <link rel="shortcut icon" href="favicon.ico">  
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
    <!-- Global CSS -->
    <link rel="stylesheet" href="assets/plugins/bootstrap/css/bootstrap.min.css">   
    <!-- Plugins CSS -->    
    <link rel="stylesheet" href="assets/plugins/font-awesome/css/font-awesome.css">
    <link rel="stylesheet" href="assets/plugins/prism/prism.css">
    <link rel="stylesheet" href="assets/plugins/lightbox/dist/ekko-lightbox.min.css">
    <link rel="stylesheet" href="assets/plugins/elegant_font/css/style.css">

    <!-- Theme CSS -->
    <link id="theme-style" rel="stylesheet" href="assets/css/styles.css">
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    
</head> 

<body class="body-blue">
    <div class="page-wrapper">
        <!-- ******Header****** -->
        <header id="header" class="header">
            <div class="container">
                <div class="branding">
                    <h1 class="logo">
                        <a href="index.html">
                            <span aria-hidden="true" class="icon_documents_alt icon"></span>
                	    <span class="text-bold">Documentation</span>
                        </a>
                    </h1>
                </div><!--//branding-->
                <ol class="breadcrumb">
                    <li><a href="index.html">Accueil</a></li>
                    <li class="active">Compréhension du protocole</li>
                </ol>
            </div><!--//container-->
        </header><!--//header-->
        <div class="doc-wrapper">
            <div class="container">
                <div id="doc-header" class="doc-header text-center">
                    <h1 class="doc-title"><span aria-hidden="true" class="icon  icon_globe-2"></span> Compréhension du protocole</h1>
                    <div class="meta"><i class="fa fa-clock-o"></i> Dernière mise à jour: 28 Février 2018</div>
                </div><!--//doc-header-->
                <div class="doc-body">
                    <div class="doc-content">
                       <section id="presentation" class="doc-section">
                                <h2 class="section-title">Présentation</h2>
                                <div id="synopsis"  class="section-block">
                                    <h3 class="block-title">Synopsis</h3>
                                    <p>Mais comment fonctionne cette bombe ? Il est temps de découvrir le fonctionnement du protocole ... Plongez dans les arcanes du système, et désamorcez la bombe !
				<div class="callout-block callout-info">
								        <div class="icon-holder">
								            <i class="fa fa-info-circle"></i>
								        </div><!--//icon-holder-->
								        <div class="content">
								            <h4 class="callout-title">Votre mission</h4>
								            <p>désamorcer la bombe ! Comprenez le rôle des différents fichiers, l'implémentation du protocole de chiffrement, et parvenez à déterminer le message à envoyer pour stopper le compteur.</p>
                                        </div><!--//content-->
                                    </div>
                                    </p>
				<div id="investigation" class="section-block">
                                        <h3 class="block-title">Examen du système</h3>
					<p>Pour mener à bien cette dernière étape, plusieurs approches sont possibles, mais il sera nécessaire de pouvoir utiliser l'application Android précédemment découverte. L'accès sur le Raspberry Pi que vous avez eu à obtenir à l'étape précédente est également indispensable pour comprendre le fonctionnement. Il n'est pas non plus nécessaire de modifier les codes sources pour réussir cette étape.</p>
					</div>
				<div id="niveaux" class="section-block">
                                        <h3 class="block-title">C'est parti !</h3>
					<p>Cette page de documentation est séparée en trois parties, selon le niveau du joueur en sécurité informatique. Vous pouvez sélectionner l'un des trois boutons ci dessous, pour accéder à la présentation des indices spécifiques à votre niveau.</p>
				<div class="row" style="margin:10px;text-align:center;">
                                        <div class="col-md-4 col-sm-4 col-xs-12">
                                            <a href="#debutant" class="scrollto btn btn-green"><span class="icon icon_lifesaver"></span> Niveau Débutant</a>
					</div>
                                        <div class="col-md-4 col-sm-4 col-xs-12">
                                            <a href="#intermediaire" class="scrollto btn btn-orange"><span class="icon icon_mug_alt"></span> Niveau Intermédiaire</a>
					</div>
                                        <div class="col-md-4 col-sm-4 col-xs-12">
                                            <a href="#expert" class="scrollto btn btn-red"><span class="icon icon_genius"></span> Niveau Expert</a>
					</div>    
					                                             
                                </div>
<p>Si vous n'avez jamais pratiqué de sniffing réseau et/ou que vous ne disposez pas d'un socle de connaissances minimal sur les fonctions de hachage et de chiffrement, sélectionnez le niveau débutant.</p>
<p>Si vous êtes bloqués, n'hésitez pas à nous contacter ... Vous pouvez également visionner la solution directement en fin de page</p>
					<div class="row">
						<div class="col-md-12 col-sm-12 col-xs-12" style="text-align:center">
						    <a href="#solution" class="scrollto btn btn-blue">Solution</a>
						</div>  
					</div>
					</div>
                                </div><!--//section-block-->
                                
                            </section><!--//doc-section-->
                       <section id="expert" class="doc-section">
                                <h2 class="section-title"><span class="icon icon_genius"></span>  Niveau Expert</h2>
                                <div class="section-block">
                                    <p>Alors, prêts pour la dernière étape ? ;) Comme vous l'avez deviné, l'objectif ici est de désamorcer la bombe, en transmettant le ou les messages nécessaires au composant qui contrôle le compteur.</p>
<p>Dans cette partie, on ne vous fournira pas non plus d'indices particuliers. Cependant, nous voulons surtout attirer votre attention sur une problématique en particulier : <b> une fois chiffré, le message peut contenir des caractères non imprimables</b>. Afin de palier à cette problématique, nous avons converti chaque octet en son équivalent hexadécimal à l'aide des fonctions <em>bin2hex</em> / <em>hex2bin</em>. Nous le précisons car c'est un point que vous pouvez difficilement découvrir par vous même.</p>
<p>Il existe plusieurs stratégies pour résoudre ce dernier challenge, de difficultés inégales. Nous en avons exploré quelques unes, mais nous sommes curieux de découvrir la votre ! Donc si vous avez résolu cette étape d'une façon originale, minutieuse, ultra efficace ou poétique, nous serons heureux d'échanger avec vous !</p>
<p style="text-align:center"><img src="assets/images/challenge/drhorrible.jpg" /> <h4 style="text-align:center">Bonne chance et bon courage !</h4></p>

                                </div><!--//section-block-->
                       </section><!--//doc-section-->
                       <section id="intermediaire" class="doc-section">
                                <h2 class="section-title"><span class="icon icon_mug_alt"></span>  Niveau Intermédiaire</h2>
                                <div class="section-block">
                                    <p>Le niveau intermédiaire pour ce challenge correspond à un certain nombre de connaissances de bases sur les fonctions de hachage, le chiffrement symétrique et le sniffing réseau. Sans vous mâcher le travail, nous allons essayer de vous faire profiter de quelques indices dans votre quête.</p>
<h3 id="sniff" class="block-title">Ecoute passive du réseau</h3>
<p>Pour arriver à vos fins, il va falloir trouver un moyen de comprendre les informations circulant en clair sur le réseau local.</p>
<p>Pour cela, nous vous suggérons d'utiliser l'utilitaire <code>tcpdump</code>. Voici un rappel de quelques options de tcpdump :</p>
<code>tcpdump &lt;options facultatives&gt; &lt;expression de filtrage&gt;</code>

<p>
- <strong> Les options facultatives </strong> : 
<ul>
<li><em>-A :</em> affiche chaque paquet sniffé en ASCII</li>
<li><em>-i &lt;interface&gt; :</em> spécifie l'utilisation d'une interface en particulier</li>
<li><em>-c &lt;nb&gt;  :</em> indique le nombre de paquets à sniffer avant interruption du programme</li>
<li><em>-D :</em>affiche la liste des interfaces disponibles pour capturer des paquets</li>
<li><em>-e :</em>affiche les entêtes des paquets de la couche liaison</li>
<li><em>-I :</em>règle l'interface en mode moniteur</li>
<li><em>-l :</em>bufferise la sortie standard (utile pour traiter les paquets capturés au fur et à mesure avec un pipe)</li>
<li><em>-# :</em>affiche un numéro avant chaque paquet </li>

</ul>
<h6> Quelques exemples d'expressions de filtrage</h6>
<ul>
<li><em>host 10.0.0.1 :</em> affiche uniquement les paquets à destination ou en provenance de l'hôte 10.0.0.1</li>
<li><em>host A and not B :</em> affiche tout les paquets entre A et n'importe quel hôte sauf B</li>
<li><em>tcp port 1234 : </em> affiche tout les paquets à destination ou en provenance du port 1234</li>
<li><em>port ftp or ftp-data :</em>affiche les paquets correspondant au protocole ftp</li>
</ul>
<strong>Les différentes expressions sont combinables à l'aide des opérateurs logiques courants (and, or, not) et peuvent être parenthésées. </strong>
</p>
<h3 id="examensources" class="block-title">Examen des sources</h3>
<p>
Il est probable que vous ayiez à examiner les codes sources à votre disposition. Les fonctions utilisées ne sont à priori pas très complexes, et leur nom est assez explicite. Voici quelques remarques cependant :
<ul>
<li>les fonctions <em>system</em>, <em>shell_exec</em> et <em>passthru</em> sont quasiment équivalentes, et permettent d'exécuter la chaîne passée en argument comme une commande bash (seul le traitement du retour de la commande varie)</li>
<li>les variables en PHP sont toutes précédées d'un symbole dollar ($)</li>
<li>la fonction hash($arg1,$arg2) en PHP est destinée à produire l'empreinte de $arg2 par la fonction de hachage définie en $arg1 (ex : "md5", "sha1"...)</li>
<li>la communication par l'intermédiaire d'une liaison série en python se manipule exactement de la même manière qu'un fichier (méthode write et read/readline)</li>
</ul>
</p>
<p>N'hésitez pas à examiner en détail les codes sources disponibles. L'objectif est de comprendre le fonctionnement général du système, pour en déduire une marche à suivre.</p>
<h3 id="chiffrementotp" class="block-title">Le chiffrement : One Time Pad</h3>
<p>Vous aurez à étudier le fonctionnement d'un binaire dont vous ne disposez pas du code source : le programme <em>onetimepad</em>. Il n'est normalement pas utile (mais si vous vous sentez motivés, faites vous plaisir !) de procéder à une analyse statique / dynamique du binaire pour en comprendre le fonctionnement.</p>
<p style="text-align:center"><img src="assets/images/challenge/onetimepad.jpg" /></p>
<p>Pour rappel, le chiffrement dit "One Time Pad" est une technique de chiffrement symétrique basée sur l'opérateur logique XOR (ou Exclusif). Il s'agit de réaliser le ou exclusif bit à bit d'un message par rapport à une clé. Il s'agit d'un des chiffrement les plus sûrs si les contraintes suivantes sont respectées : </p>
<ol>
<li>La clé doit être générée <u>aléatoirement</u></li>
<li>La clé doit être de <u>même longueur</u> que le message clair à chiffrer</li>
<li>Le clé ne doit <u>jamais être réutilisée</u></li>
</ol>
<p>Evidemment, si nous vous demandons d'attaquer un tel chiffrement, il est probable qu'une (ou plusieurs) de ces contraintes n'ait pas été respectée. Nous vous encourageons à procéder avec méthode, éventuellement en simulant le comportement de ce chiffrement sur un octet par exemple, pour mieux cerner la raison de ces différentes contraintes.</p>
<p>Pour réaliser l'attaque, la solution la plus efficace est de développer un petit script. Celui ci ne devrait pas être particulièrement complexe, et n'importe quel langage de script avec lequel vous vous sentez à l'aise devrait faire l'affaire. Si vous avez besoin d'un petit coup de pouce pour ce script, vous pouvez vous rendre dans la section "Niveau débutant", où nous proposons une petite bibliothèque python pour vous faciliter le développement.</p>
<div class="callout-block callout-warning">
                                        <div class="icon-holder">
                                            <i class="fa fa-bug"></i>
                                        </div><!--//icon-holder-->
                                        <div class="content">
                                            <h4 class="callout-title">Attention !</h4>
                                            <p>L'opération de XOR appliquée à des caractères ASCII peut parfois produire des caractères non imprimables. Pour éviter cet inconvénient, nous avons utilisé dans l'implémentation des fonctions d'encodage et de décodage en hexadécimal : il s'agit des fonctions <em>bin2hex</em> (binaire vers hexadécimal) et <em>hex2bin</em> (hexadécimal vers binaire). Le chiffrement doit être réalisé sur des données binaires, mais l'affichage doit se faire en hexadécimal !</p>

                                        </div><!--//content-->
                                    </div><!--//callout-block-->
	
                                </div><!--//section-block-->
<h3 id="envoichiffre" class="block-title">L'envoi du message</h3>
<p>Un dernier conseil : pour l'envoi du message, inutile de chercher midi à quatorze heures ! Aucun code supplémentaire n'est nécessaire, n'hésitez pas à réutiliser des composants déjà existants.</p>
                       </section><!--//doc-section-->
                       <section id="debutant" class="doc-section">
                                <h2 class="section-title"><span class="icon icon_lifesaver"></span>  Niveau Débutant</h2>
                                <div class="section-block">   
                                    <div id="connection" class="section-block">
                                        <h3 id="comprehension" class="block-title">Compréhension du protocole de communication</h3>
					<p>Pour réussir cette dernière étape, il va être nécessaire d'examiner les codes sources à votre disposition et de sniffer les paquets transitant sur le réseau. Pour cette tâche, vous pouvez mettre à profit le shell distant obtenu dans l'étape précédente.</p>
					<p>Voici quelques commandes shell qui peuvent se révéler utiles dans cette démarche :</p>
					<ul>
					<li><code>ls</code> : liste le contenu du dossier courant</li>
					<li><code>pwd</code> : indique l'emplacement du dossier courant</li>
					<li><code>cd &lt;dossier&gt;</code> : se déplace dans le dossier indiqué</li>
					<li><code>cd ..</code> : remonte dans le dossier parent</li>
					<li><code>cat &lt;fichier&gt;</code> : affiche le contenu du fichier indiqué</li>
					<li><code>echo -n "machaine" | sha1sum</code> : donne l'empreinte de la chaîne "machaine" par la fonction de hachage sha1</li>
					</ul>
<h4>1. Examen des codes sources</h4>
<p>Une bonne étape pour commencer est d'examiner le contenu des différents fichiers dont vous ne connaissez pas encore le fonctionnement. Pour cela, n'hésitez pas à consulter le contenu et chercher à comprendre les différentes technologies et leur fonctionnement.</p>
<p>Le protocole utilise, pour fonctionner, trois technologies différentes : deux langages interprétés (vous pouvez donc consulter le code source des scripts concernés) et un langage compilé (vous n'avez donc accès qu'à l'exécutable, sans moyen de consulter le code source). </p>
<p>Pour vous aider, voici une explication succinte du rôle de quelques fonctions PHP et python : </p>
<div class="row">
<div class="col-md-6 col-sm-6 col-xs-6">
<h5>Fonctions PHP</h5>
<ul>
<li><code>system($arg)</code>: exécuter l'argument $arg comme s'il s'agissait d'une commande bash, et afficher le retour de la commande</li>
<li><code>shell_exec($arg)</code>: exécuter l'argument $arg comme s'il s'agissait d'une commande bash, et retourner le retour de la commande</li>
<li><code>passthru($arg)</code>: exécuter l'argument $arg comme s'il s'agissait d'une commande bash, et retourner le retour de la commande</li>
<li><code>header($arg)</code>: modifier le header par défaut de la page renvoyée par le script</li>
<li><code>hash($arg1,$arg2)</code>: renvoie l'empreinte de $arg2 par la fonction de hachage spécifiée en $arg1 (md5, sha1, sha256...)</li>
<li><code>in_array($arg1,$arg2)</code>: renvoie true (vrai) si l'argument $arg1 est contenu dans le tableau $arg2, sinon renvoie false (faux)</li>
</ul>
</div>
<div class="col-md-6 col-sm-6 col-xs-6">
<h5>Fonctions Python</h5>
<ul>
<li><code>sha.new(arg).hexdigest()</code>: renvoie l'empreinte de arg par la fonction de hachage sha1</li>
<li><code>serial.Serial(arg1,arg2)</code>: déclare un objet permettant une communication série sur la liaison série arg1, cadence la communication à arg2 Bauds</li>
<li><code>&lt;objet serial&gt;.write(arg)</code>: envoie la chaîne de caractère arg par l'intermédiaire de la liaison série</li>
<li><code>&lt;objet serial&gt;.readline()</code>: retourne la ligne reçue par la liaison série</li>
<li><code>&lt;objet serial&gt;.write(arg)</code>: envoie la chaîne de caractère arg par l'intermédiaire de la liaison série</li>
<li><code>&lt;objet serial&gt;.readline()</code>: retourne la ligne reçue par la liaison série</li>
<li><code>time.sleep(arg)</code>: provoque une attente de arg secondes</li>
</ul>
</div>
</div>
<h4>2. Écoute passive du réseau</h4>
<p>A ce stade, vous devriez commencer à avoir une bonne idée du fonctionnement du protocole de communication. Il y a trois entités à identifier. Cependant, il n'est pas possible en se contentant de lire les sources de comprendre quelles informations sont reçues par le Raspberry Pi, avant d'être transformées et redirigées sur la liaison série à destination de l'Arduino. Pour pouvoir expérimentalement retrouver les messages reçus, il va être nécessaire de procéder à une écoute (ou <i>sniffing</i>) du réseau, sur l'interface wifi. Cela va nous permettre, en utilisant le téléphone Android pour envoyer des messages, de comprendre comment ceux ci sont construits.</p>
<p>Pour réaliser cette écoute, il est possible d'utiliser l'excellent logiciel <code>tcpdump</code>, directement dans le shell. Voici la syntaxe que nous vous proposons :</p>
<p style="text-align:center"><code>tcpdump -c 20 -s 0 -A host 192.168.4.1 and tcp port http</code></p>
<p> L'option <em>-c</em> vous permet de choisir le nombre de paquets à récupérer avant d'interrompre l'écoute, l'option <em>-s 0</em> permet d'éviter d'imposer une limite de taille aux paquets reçus, l'option <em>-A</em> demande à tcpdump d'afficher les paquets avec un affichage ASCII, plus pratique pour examiner des paquets HTTP, et la chaîne  <em>host 192.168.4.1 and tcp port http</em> permet de limiter les paquets reçus à ceux à destination ou en provenance de l'hôte 192.168.4.1 (le Raspberry Pi) et étant des paquets HTTP utilisant le protocole TCP.</p>
<p>Examinez les paquets transmis lorsque vous utilisez une commande sur le téléphone, et déduisez en un schéma de construction. Cela vous sera utile pour comprendre quel message transmettre pour stopper la bombe ! </p>
<h4>3. La fonction de chiffrement</h4>
<p>Vous devriez maintenant connaître le message clair, et avoir compris que celui ci va être chiffré par un programme nommé <strong>onetimepad</strong>. Ce programme, d'après son nom, utilise un chiffrement symétrique particulier, appellé One Time Pad. Il s'agit de chiffrer un message à l'aide de l'opérateur logique XOR.</p>
<p> Pour rappel, la table de vérité de l'opérateur XOR est la suivante :</p>
<p style="text-align:center"><pre><code>0 xor 0 = 0
0 xor 1 = 1
1 xor 0 = 1
1 xor 1 = 0</code></pre>
</p>                    
<p>Ainsi, si on utilise une clé de chiffrement unique pour chaque message à chiffrer, il s'agit d'une fonction de chiffrement très efficace et très sûre. Voici par exemple le chiffrement et le déchiffrement d'un octet par cette méthode :  </p>
<p style="text-align:center"><pre><code>
MESSAGE CLAIR : 0 1 0 0 1 1 0 1
CLE DE CHIFF. : 1 0 1 0 1 0 1 0
==========chiffrement==========
MESSAGE CHIFF.: 1 1 1 0 0 1 1 1

CLE DE CHIFF. : 1 0 1 0 1 0 1 0
=========dechiffrement=========
MESSAGE CLAIR : 0 1 0 0 1 1 0 1
</code></pre>
</p>    
<p>
Cependant, ce type de chiffrement impose que la clé et le message soit de la même taille, ce qui est une contrainte potentiellement contraignante. Cela donne d'ailleurs un sens à l'emploi d'une fonction de hachage dans le protocole ... un autre problème de taille est qu'il devient particulièrement dangereux d'utiliser ce type de chiffrement si la clé de chiffrement est <strong>réutilisée</strong> pour chiffrer plusieurs messages. En effet, à partir d'un message clair et du chiffré correspondant, il est possible de retrouver la clé.
</p>
<h3 id="exploitation" class="block-title">L'exploitation</h3>
<p>A ce stade, vous disposez de tout les éléments pour mener à bien cette exploitation. Pour réussir cette étape, vous allez devoir retrouver la clé à partir des éléments dont vous disposez, chiffrer le bon message pour stopper la bombe, et utiliser le même canal que le Raspberry Pi utilise pour communiquer ce dernier à l'Arduino.</p>
<p>Pour réaliser cela, nous vous proposons d'essayer d'écrire un petit script python. Pour vous faciliter la tâche, nous avons réalisé une petite bibliothèque comportant un certain nombre de fonctionnalités utiles, que vous pouvez utiliser pour implémenter votre script.</p>
<div class="callout-block callout-warning">
                                        <div class="icon-holder">
                                            <i class="fa fa-bug"></i>
                                        </div><!--//icon-holder-->
                                        <div class="content">
                                            <h4 class="callout-title">Attention !</h4>
                                            <p>L'opération de XOR appliquée à des caractères ASCII peut parfois produire des caractères non imprimables. Pour éviter cet inconvénient, nous avons utilisé dans l'implémentation des fonctions d'encodage et de décodage en hexadécimal : il s'agit des fonctions <em>bin2hex</em> (binaire vers hexadécimal) et <em>hex2bin</em> (hexadécimal vers binaire). Le chiffrement doit être réalisé sur des données binaires, mais l'affichage doit se faire en hexadécimal !</p>

                                        </div><!--//content-->
                                    </div><!--//callout-block-->
	
                                </div><!--//section-block-->
<p>Voici la mini bibliothèque que nous vous proposons : </p>
<p><pre>
<code  class="language-python">#encoding:utf-8
import sha,string

# Conversion d'une chaîne de caractères contenant des caractères non imprimables en hexadécimal
def bin2hex(binn):
	ret = binn.encode('hex')
	return ret

# Conversion d'une chaîne de caractères en hexadécimal en binaire (caractères potentiellement non imprimables)
def hex2bin(hex):
	ret = hex.decode('hex')
	return ret

# Chiffrement de la chaîne data par la clé key par la méthode de chiffrement One Time Pad
def string_xor(data, key): 
    return str(bytearray(a^b for a, b in zip(*map(bytearray, [data, key]))))

# Fonction de hachage sha1
def sha1(clair):
	return sha.new(clair).hexdigest()
</code>
</pre></p>
<p>Bon courage !</p>
            </div><!--//section-block-->
                       </section><!--//doc-section-->
 			<section id="solution" class="doc-section">
                                <h2 class="section-title"><span class="icon icon_key_alt"></span>   La Solution</h2>
                                <div class="section-block">
                                    <p style="text-align:center;"><button id="btnsolution" onclick="switcherSolution()" class="btn btn-blue">Afficher la solution</button></p>
					
				<div style="display:none;"id="lasolutioncachee">
<p>				Pour découvrir la solution de cette dernière étape et désamorcer la bombe, il est nécessaire de bien comprendre le protocole de communication. On a donc trois entités matérielles qui communiquent entre elles : 
</p>
<ul>
<li><strong>Le téléphone Android :</strong> le téléphone Android est lui aussi connecté au réseau local sans fil proposé par le Raspberry Pi. L'application permet de contrôler la bombe, au travers de trois boutons utilisables (START, CHANGE_BGCOLOR et CHANGE_FGCOLOR) et un bouton désactivé (STOP). Il communique par des requêtes HTTP de type GET, et transmet le message (START, par exemple) concaténé à la chaine de caractères ZESECRET. <em>Il était possible de découvrir ces informations en sniffant le réseau local avec tcpdump et en déclenchant les boutons disponibles.</em></li>
<li><strong>Le Raspberry Pi :</strong> il héberge un serveur web, et propose de manipuler la bombe par l'intermédiaire du fichier "action.php". Ce fichier vérifie tout d'abord que le message clair reçu est bien autorisé (en comparant les hachés des messages clairs attendus avec le haché de l'information reçue). Il envoie ensuite ce contenu haché (en sha1) en entrée d'un programme C nommé "onetimepad", qui effectue un chiffrement One Time Pad en réutilisant la même clé.<em>Il était possible de découvrir ces informations en consultant les codes sources et en faisant quelques tests avec le programme "onetimepad".</em></li>
<li><strong>L'arduino :</strong> c'est lui qui gère le fonctionnement de la bombe. Il communique avec le Raspberry Pi par l'intermédiaire de la liaison série. Pour transmettre un message à l'arduino, il faut utiliser le programme "send.py", disponible sur le serveur web.<em> Il était possible de découvrir cette information en lisant le code source</em></li>
</ul>
<p>Le parcours d'un message est donc le suivant : </p>
<pre>
<code>     message START
          |
        [ANDROID]
          |
      STARTZESECRET
          |
[RASPBERRY PI : action.php]
          |
   sha1(STARTZESECRET)
          |
[RASPBERRY PI : onetimepad]
          |
  xor(sha1(secret),clé)
          |
[RASPBERRY PI : send.py]
          |
      [ARDUINO]</code></pre>
<p>Pour forger le message permettant de stopper la bombe, la procédure est donc la suivante :</p>
<ol>
<li><strong>Concaténer la chaîne ZESECRET au message initial :</strong> On obtient donc le message <em>STOPZESECRET</em></li>
<li><strong>Calculer l'empreinte sha1 du message STOPZESECRET :</strong> Pour réaliser cette opération, il est possible d'utiliser directement un interpréteur de commande bash en utilisant la commande : <code> echo -n "STOPZESECRET" | sha1sum</code>. On obtient l'empreinte "22dd78f1b8dbb2a1b716ed0858880e0e3da8d07c".</li>
<li><strong>Retrouver la clé du chiffrement One Time Pad :</strong> Il était facile de vérifier que la clé est identique d'un message à l'autre, car on possède plusieurs couples clair / chiffré. Pour retrouver la clé, il suffisait donc de procéder à l'opération de xor entre le clair et le chiffré. Le script suivant réalise cette opération :
<p><pre>
<code  class="language-python">#encoding:utf-8
import sha,string

# Conversion d'une chaîne de caractères contenant des caractères non imprimables en hexadécimal
def bin2hex(binn):
	ret = binn.encode('hex')
	return ret

# Conversion d'une chaîne de caractères en hexadécimal en binaire (caractères potentiellement non imprimables)
def hex2bin(hex):
	ret = hex.decode('hex')
	return ret

# Chiffrement de la chaîne data par la clé key par la méthode de chiffrement One Time Pad
def string_xor(data, key): 
    return str(bytearray(a^b for a, b in zip(*map(bytearray, [data, key]))))

# Fonction de hachage sha1
def sha1(clair):
	return sha.new(clair).hexdigest()

message = "STARTZESECRET"
clair1 = sha1(message)
# La valeur suivante a été récupérée de la sortie du programme onetimepad pour l'entrée STARTZESECRET
chiffre1 = hex2bin("010e0500050d5355040109575d0350070f525d5d0403060052575b5807505c075d52530e01535602") 
cle = string_xor(clair1,chiffre1)
print "Clé : " + cle
</code>
</pre></p>
On obtient finalement la clé "891a65af2c83dff47a9dabb30c8971dcecb9bc06".
</li>
<li><strong>Chiffrer notre message avec la clé :</strong> Il ne nous reste plus qu'à utiliser les informations précédemment récupérées pour chiffrer le message "STOPZESECRET" en one time pad. Attention cependant à convertir le résultat en hexadécimal : en effet, un certain nombre de caractères ne sont pas imprimables à l'issue du chiffrement. Pour pouvoir néanmoins manipuler les chiffrés, la fonction bin2hex a été implémentée. Voici donc le script final :
<p><pre><code class="language-python">
#encoding:utf-8
import sha,string

# Conversion d'une chaîne de caractères contenant des caractères non imprimables en hexadécimal
def bin2hex(binn):
	ret = binn.encode('hex')
	return ret

# Conversion d'une chaîne de caractères en hexadécimal en binaire (caractères potentiellement non imprimables)
def hex2bin(hex):
	ret = hex.decode('hex')
	return ret

# Chiffrement de la chaîne data par la clé key par la méthode de chiffrement One Time Pad
def string_xor(data, key): 
    return str(bytearray(a^b for a, b in zip(*map(bytearray, [data, key]))))

# Fonction de hachage sha1
def sha1(clair):
	return sha.new(clair).hexdigest()


message = "STARTZESECRET"
clair1 = sha1(message)
chiffre1 = hex2bin("010e0500050d5355040109575d0350070f525d5d0403060052575b5807505c075d52530e01535602")
cle = string_xor(clair1,chiffre1)
print "Clé : " + cle
clair2 = sha1("STOPZESECRET")
print "Msg:" + bin2hex(string_xor(clair2,cle))
</code>
</pre></p>
On obtient le message chiffré suivant : "0a0b5505010d0757505b5c5106540705555608520406520b055b0001075454065607030106530755".
</li>
<li><strong>Envoyer le message chiffré à l'arduino :</strong> Finalement, il ne reste plus qu'à envoyer le message en utilisant le shell obtenu à l'étape précédente. On peut utiliser le programme python send.py, déjà existant. L'envoi du message est donc réalisé en tapant :<br />
<code>python send.py 0a0b5505010d0757505b5c5106540705555608520406520b055b0001075454065607030106530755</code>
</li>
</ol>
				</div>
                                </div><!--//section-block-->
                       </section><!--//doc-section-->
                    </div><!--//doc-content-->
                    <div class="doc-sidebar">
                        <nav id="doc-nav">
                            <ul id="doc-menu" class="nav doc-menu hidden-xs" data-spy="affix">
                                <li><a class="scrollto" href="#presentation">Présentation</a></li>
                                <li><a class="scrollto" href="#expert">Niveau Expert</a></li>
                                <li><a class="scrollto" href="#intermediaire">Niveau Intermédiaire</a></li>
				<ul class="nav doc-sub-menu">
		                        <li><a class="scrollto" href="#sniff">Ecoute passive du réseau</a></li>
		                        <li><a class="scrollto" href="#examensources">L'examen des sources</a></li>
					<li><a class="scrollto" href="#chiffrementotp">Le chiffrement</a></li>
<li><a class="scrollto" href="#envoichiffre">L'envoi du message</a></li>				    </ul>
                                <li><a class="scrollto" href="#debutant">Niveau Débutant</a></li>
                                    <ul class="nav doc-sub-menu">
		                        <li><a class="scrollto" href="#comprehension">Compréhension du protocole</a></li>
		                        <li><a class="scrollto" href="#exploitation">Exploitation</a></li>
				    </ul>
                                <li><a class="scrollto" href="#solution">La Solution</a></li>
                            </ul><!--//doc-menu-->
                        </nav>
                    </div><!--//doc-sidebar-->
                </div><!--//doc-body-->              
            </div><!--//container-->
        </div><!--//doc-wrapper-->
        

        
    </div><!--//page-wrapper-->
    
    <footer id="footer" class="footer text-center">
        <div class="container">
            <!--/* This template is released under the Creative Commons Attribution 3.0 License. Please keep the attribution link below when using for your own project. Thank you for your support. :) If you'd like to use the template without the attribution, you can check out other license options via our website: themes.3rdwavemedia.com */-->
            <small class="copyright">Développé avec <i class="fa fa-heart"></i> par Romain Cayre et Huon Duong Tran</small>
            
        </div><!--//container-->
    </footer><!--//footer-->
    
     
    <!-- Main Javascript -->         
    <script type="text/javascript">
	function switcherSolution() {
		bouton = document.querySelector('#btnsolution');
		solution = document.querySelector('#lasolutioncachee');
		if (solution.style.display == "none") {
			solution.style.display = "block";
			bouton.innerHTML = "Masquer la solution";		
		}
		else {
			solution.style.display = "none";
			bouton.innerHTML = "Afficher la solution";
		}
	}
    </script> 
    <script type="text/javascript" src="assets/plugins/jquery-1.12.3.min.js"></script>
    <script type="text/javascript" src="assets/plugins/bootstrap/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="assets/plugins/prism/prism.js"></script>    
    <script type="text/javascript" src="assets/plugins/jquery-scrollTo/jquery.scrollTo.min.js"></script>  
    <script type="text/javascript" src="assets/plugins/lightbox/dist/ekko-lightbox.min.js"></script>                                                                 
    <script type="text/javascript" src="assets/plugins/jquery-match-height/jquery.matchHeight-min.js"></script>
    <script type="text/javascript" src="assets/js/main.js"></script>
    
</body>
</html> 

